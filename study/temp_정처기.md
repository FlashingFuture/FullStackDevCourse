# 요구사항 확인

## 소프트웨어 생명 주기

### 소프트웨어 생명 주기

소프트웨어 생명 주기: 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것

- 폭포수, 프로토타입, 나선형, 에자일 모형 등

### 폭포수 모형(Waterfall Model)

폭포수 모형: 각 단계를 확실히 매듭짓고 그 결과를 검토하여 승인 과정을 거친 후 다음 단계를 진행하는 개발 방법론

- 고전적 생명 주기 모형
- 각 단계가 끝난 후 다음 단계를 수행하기 위한 결과물이 명확히 산출되어야 함

### 프로토타입 모형(Prototype Model)

프로토타입 모형: 실제 개발될 소프트웨어에 대한 견본(Prototype)을 만들어 최종 결과물을 예측하는 모형

### 나선형 모형(Spiral Model)

나선형 모형: 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 최종 소프트웨어를 개발하는 모형

### 에자일 모형(Agile Model)

에자일 모형: 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형

- 스크럼, XP, 칸반, Lean, FDD 등의 개발 모형

#### 에자일 개발 4가지 핵심 가치

- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 더 가치를 둠
- 계약 협상보다는 고객과의 협업에 더 가치를 둠
- 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둠

### 소프트웨어 공학(Software Engineering)

소프트웨어 공학: 소프트웨어의 위기를 극복하기 위한 방안

## 스크럼

### 스크럼(Scrum)

스크럼: 팀이 중심이 되어 개발의 효율성을 높이는 기법

#### 스크럼 팀

- 제품 책임자(PO): 요구사항이 담긴 백로그를 작성하는 주체로, 이해관계자 중 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 의사를 결정할 사람으로 선정
- 스크럼 마스터(SM): 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행

### 스크럼 개발 프로세스

- 스프린트: 실제 개발 작업을 진행하는 과정으로 보통 2~4주 정도의 기간 내에서 진행
- 일일 스크럼 회의: 매일 약속된 시간에 진행 상황을 점검하는 회의로, 남은 작업 시간을 소멸 차트(Burn-down Chart)에 표시

## XP(eXtreme Programming)

XP: 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법

- XP의 5가지 핵심 가치: 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)

### XP 개발 프로세스

- 릴리즈 계획 수립: 부분 / 전체 개발 완료 시점에 대한 일정을 수립하는 것
- 이터레이션: 실제 개발 작업을 진행하는 과정으로 보통 1~3주 정도의 기간으로 진행
- 승인 검사: 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트
- 소규모 릴리즈: 요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것

### XP의 주요 실천 방법

- 페어 프로그래밍: 다른 사람과 함께 프로그래밍을 수행함으로써 개발의 책임을 공동으로 소유함
- 공동 코드 소유(Collective Ownership): 개발 코드에 대한 권한과 책임을 공동으로 소유
- 테스트 주도 개발(TDD): 실제 코드 작성 전 테스트 케이스를 먼저 작성함으로써 자신이 무엇을 해야할지를 정확히 파악
- 계속적 통합(Continuous Integration): 모듈 단위로 나눠 개발한 코드들을 하나의 작업이 마무리 될 때마다 지속적으로 통합함
- 리팩토링: 프로그램 기능의 변경 없이 시스템을 재구성
  - 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하는 목적을 가짐

## 개발 기술 환경 파악

### 운영체제

운영체제: 컴퓨터 시스템의 자원을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어

- 운영체제 관련 요구사항 식별 시 고려사항: 가용성, 성능, 기술 지원, 주변 기기, 구축 비용

### 데이터베이스 관리 시스템(DBMS: DataBase Management Systemp)

DBMS: 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고 데이터베이스를 관리해 주는 소프트웨어

- DBMS 관련 요구사항 식별 시 고려사항: 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

### 웹 어플리케이션 서버(WAS: Web Application Server)

WAS: 사용자의 요구에 따라 변하는 동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어

- WAS 관련 요구사항 식별 시 고려사항: 가용성, 성능, 기술 지원, 구축 비용

### 오픈 소스

오픈소스: 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어

- 오픈소스 관련 요구사항 식별 시 고려사항: 라이선스의 종류, 사용자 수, 기술의 지속가능성

## 요구사항 정의

요구사항: 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건

- 요구사항의 유형: 기능 요구사항, 비기능 요구사항, 사용자 요구사항, 시스템 요구사항

### 기능 요구사항

기능 요구사항: 기능이나 수행에 관련된 요구사항

- 시스템 입출력에 포함되어야 하는 사항
- 시스템의 데이터 저장과 연산 수행에 대한 사항
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

### 비기능 요구사항

비기능 요구사항: 품질이나 제약사항과 관련된 요구사항

- 시스템 장비 구성 요구사항
- 성능 요구사항
- 인터페이스 요구사항
- 테스트 요구사항
- 보안 요구사항
- 프로젝트 관리, 자원 요구사항
- 제약사항

### 사용자 요구사항

사용자 요구사항: 사용자 관점에서 본 시스템이 제공해야 할 요구사항

### 시스템 요구사항

시스템 요구사항: 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

## 요구사항 개발 프로세스

요구사항 개발 프로세스: 개발 대상에 대한 요구사항을 체계적으로 도출하고 분석 후 명세서에 정리하여 확인 및 검증하는 일련의 구조화된 활동

- **도출**, **분석**, **명세**, **확인**으로 나뉨

### 요구사항 도출

요구사항 도출: 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할지 식별하고 이해하는 과정

- 소프트웨어 개발 생명 주기 동안 지속적으로 반복됨
- 요구사항을 도출하는 주요 기법
  - 청취와 인터뷰
  - 설문
  - 브레인스토밍
  - 워크샵
  - 프로토타이핑
  - 유스케이스

### 요구사항 분석

요구사항 분석: 개발 대상에 대한 사용자의 요구사항 중 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정

- 요구사항 분석에 사용되는 도구
  - 자료 흐름도(DFD)
  - 자료 사전(DD)

### 요구사항 명세

요구사항 명세: 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미

### 요구사항 확인

요구사항 확인: 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동

- 요구사항 정의 문서들에 대한 형상 관리(SCM)를 수행

### 요구공학

요구공학: 요구사항을 정의하고 분석 및 관리하는 프로세스를 연구하는 학문

## 요구사항 분석

요구사항 분석: 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동

### 구조적 분석 기법

구조적 분석 기법: 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법

- 주요 도구: 자료 흐름도, 자료 사전, 소단위 명세서, 개체 관계도, 상태 전이도도

### 자료 흐름도(Data Flow Diagram)

자료 흐름도: 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법

### 자료 흐름도 기본 기호

| 기호      | 의미          | 표기법 예시 / 설명                      |
| --------- | ------------- | --------------------------------------- |
| ○ 또는 ⭕ | 프로세스      | 주문 처리, 계산, 검토 등 동사 형태 사용 |
| ─────►    | 데이터 흐름   | 주문서, 승인 정보 등 명사 형태 사용     |
| ▭ 또는 ▬▬ | 데이터 저장소 | 고객 정보, 제품 목록 등 명사 형태 사용  |
| ▭▭        | 외부 개체     | 고객, 관리자, 타 시스템 등              |

### 자료 사전(Data Dictionary)

자료 사전: 자료 흐름도에 있는 자료를 정의하고 기록한 것

| 기호       | 의미                          |
| ---------- | ----------------------------- |
| =          | 정의 (구성)                   |
| +          | 그리고 (AND)                  |
| ;          | 또는 (OR)                     |
| ()         | 선택 항목 (0개 또는 1개 존재) |
| {}         | 반복 항목 (0개 이상 존재)     |
| []         | 생략 가능 항목                |
| \*         | 반복 가능 (0개 이상)          |
| "" 또는 '' | 리터럴 값 또는 고정 문자열    |

### 요구사항 분석 CASE와 HIPO

### 요구사항 분석용 CASE

요구사항 분석용 CASE: 요구사항을 자동으로 분석하고 요구사항 분석 명세서를 기술하도록 개발된 도구

| 용어     | 설명                                                                            |
| -------- | ------------------------------------------------------------------------------- |
| SADT     | 기능 중심의 시스템 구조 분석 기법. 입력/출력/제어/도구를 이용해 계층적으로 표현 |
| RSL/REVS | 요구사항을 명확히 표현(RSL)하고 자동 분석/검증(REVS)하는 언어 및 도구           |
| PSL/PSA  | 시스템 동작을 형식적으로 표현(PSL)하고 논리적 오류를 분석(PSA)하는 도구         |
| TAGS     | 요구사항에 고유 식별자(ID)를 부여하여 추적성과 관리를 용이하게 함               |

### HIPO(Hierarchy Input Process Output)

HIPO: 시스템 실행 과정인 입력 / 처리 / 출력의 기능을 표현한 것

- 하향식 소프트웨어 개발을 위한 문서화 도구로써 계층 구조인 HIPO Chart로 표현할 수 있음

## UML

UML(Unified Modeling Language): 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어

- 사물(Things), 관계(Relationships), 다이어그램(Diagram)으로 구성

### Things

사물: 다이어그램 안에서 관계가 형성될 수 있는 대상들

| 유형         | 요소 이름             | 설명                                             |
| ------------ | --------------------- | ------------------------------------------------ |
| 구조적 Thing | 클래스(Class)         | 객체의 속성과 동작을 정의하는 설계 단위          |
|              | 인터페이스(Interface) | 외부에 노출되는 기능만 정의한 추상적 구조        |
|              | 협력체(Collaboration) | 여러 요소 간의 상호작용을 나타냄                 |
|              | 유스케이스(Use Case)  | 시스템이 사용자에게 제공하는 기능 단위           |
|              | 액터(Actor)           | 시스템 외부에서 동작하는 사용자나 외부 시스템    |
|              | 컴포넌트(Component)   | 물리적/논리적으로 모듈화된 코드 단위             |
|              | 노드(Node)            | 실행 환경(서버, 장비 등)                         |
| 행동적 Thing | 상호작용(Interaction) | 객체 간 메시지 교환                              |
|              | 상태(State)           | 객체가 가질 수 있는 상태와 상태 전이             |
| 그룹화 Thing | 패키지(Package)       | 관련된 요소들을 그룹화하여 구성                  |
| 주석적 Thing | 주석(Comment)         | 설명이나 메모를 추가하여 모델에 부가 정보를 제공 |

### Relationship

관계: 사물과 사물 사이의 연관성을 표현하는 것

#### 연관 (Association)

| 항목   | 설명                                           |
| ------ | ---------------------------------------------- |
| 정의   | 두 클래스가 서로 연결되어 있다는 일반적인 관계 |
| 특징   | 단방향 또는 양방향일 수 있음                   |
| 표기법 | 실선 (→ 또는 ↔)                                |
| 예시   | `학생 → 수업` (학생은 수업을 수강함)           |

#### 집합 (Aggregation)

| 항목   | 설명                                               |
| ------ | -------------------------------------------------- |
| 정의   | 전체-부분 관계, 부분이 독립적으로 존재 가능        |
| 특징   | 느슨한 전체-부분 관계                              |
| 표기법 | 빈 마름모 (◇)                                      |
| 예시   | `학급 ◇─ 학생` (학생은 학급 없이도 존재할 수 있음) |

#### 복합 (Composition)

| 항목   | 설명                                             |
| ------ | ------------------------------------------------ |
| 정의   | 강한 전체-부분 관계, 부분은 전체에 의존하여 존재 |
| 특징   | 생명주기가 전체에 종속됨                         |
| 표기법 | 채워진 마름모 (◆)                                |
| 예시   | `건물 ◆─ 방` (방은 건물 없이는 존재할 수 없음)   |

#### 일반화 (Generalization)

| 항목   | 설명                                           |
| ------ | ---------------------------------------------- |
| 정의   | 상속 관계 (is-a 관계)                          |
| 특징   | 자식 클래스가 부모 클래스의 속성과 동작을 상속 |
| 표기법 | 빈 삼각형 화살표 (△)                           |
| 예시   | `동물 △─ 개` (개는 동물의 일종)                |

#### 실체화 (Realization)

| 항목   | 설명                               |
| ------ | ---------------------------------- |
| 정의   | 클래스가 인터페이스를 구현함       |
| 특징   | 인터페이스와 구현 클래스 간의 관계 |
| 표기법 | 점선 + 빈 삼각형 화살표 (△ - - -)  |
| 예시   | `정렬기 △ - - - QuickSort`         |

#### 의존 (Dependency)

| 항목   | 설명                                                |
| ------ | --------------------------------------------------- |
| 정의   | 한 요소가 다른 요소에 영향을 받는 관계              |
| 특징   | 일시적인 관계로, 변경에 민감함                      |
| 표기법 | 점선 화살표 ( - - > )                               |
| 예시   | `A 클래스 - - > B 클래스` (A는 B를 일시적으로 사용) |

### Diagram

다이어그램: 사물과 관계를 도형으로 표현한 것

- 정적 모델링에서는 주로 구조적 다이어그램을, 동적 모델링에서는 주로 행위 다이어그램을 사용

#### 구조적(Structural) 다이어그램

| 다이어그램 이름      | 설명                                                                  |
| -------------------- | --------------------------------------------------------------------- |
| 클래스 다이어그램    | 시스템의 클래스, 속성, 메서드, 클래스 간의 관계(상속, 연관 등)를 표현 |
| 객체 다이어그램      | 클래스 다이어그램의 인스턴스화된 모습, 특정 시점의 객체 상태를 표현   |
| 컴포넌트 다이어그램  | 시스템의 컴포넌트(모듈) 구조와 그들 간의 의존 관계를 표현             |
| 배치 다이어그램      | 소프트웨어가 실행되는 하드웨어 환경(노드)과 아티팩트의 배치를 표현    |
| 복합 구조 다이어그램 | 클래스 내부의 구성 요소(포트, 파트 등)와 그 내부 구조를 표현          |
| 패키지 다이어그램    | 관련된 클래스나 컴포넌트를 패키지 단위로 묶어 구조적 관계를 표현      |

#### 행위(Behavioral) 다이어그램

| 다이어그램 이름          | 설명                                                                   |
| ------------------------ | ---------------------------------------------------------------------- |
| 유스케이스 다이어그램    | 사용자(액터)와 시스템 간의 기능적 상호작용을 모델링                    |
| 시퀀스 다이어그램        | 객체 간 메시지 교환을 시간 순서에 따라 표현                            |
| 커뮤니케이션 다이어그램  | 객체 간의 상호작용을 객체 중심으로 표현, 시퀀스와 유사하지만 구조 중심 |
| 상태 다이어그램          | 객체가 시간에 따라 가지는 상태와 상태 전이(이벤트 반응)를 표현         |
| 활동 다이어그램          | 워크플로우나 프로세스를 흐름(순서도) 형태로 표현                       |
| 상호작용 개요 다이어그램 | 여러 상호작용(시퀀스, 활동 등)을 조합한 상위 흐름을 표현               |
| 타이밍 다이어그램        | 시간에 따른 상태 변화나 이벤트 발생 시점 등을 정확히 표현              |

#### 스테레오 타입

스테레오 타입: UML 기본 기능 외에 추가적인 기능을 표현하는 것

- `<<include>>`, `<<extends>>`, `<<interface>>`, `<<exception>>`, `<<constructor>>` 등

```
사용자
  |
  v
[상품 주문]  -------->  <<include>>  -------->  [결제하기]
```

#### 유스케이스 다이어그램

유스케이스 다이어그램: 개발될 시스템이 갖춰야 할 기능을 공유하기 위해 그림으로 표현하는 것

| 구성요소                    | 표현방법                     | 내용                                                    |
| --------------------------- | ---------------------------- | ------------------------------------------------------- |
| 액터(Actor)                 | 사람 모양 아이콘 또는 스틱맨 | 시스템과 상호작용하는 외부 사용자 또는 다른 시스템      |
| 유스케이스(Use Case)        | 타원형(Oval)                 | 사용자가 시스템에서 수행할 수 있는 기능 또는 서비스     |
| 시스템(System)              | 사각형(Box)                  | 유스케이스가 포함되는 범위 또는 시스템 자체             |
| 연관 관계(Association)      | 실선(Line)                   | 액터와 유스케이스 간의 상호작용을 나타냄                |
| 포함 관계(<<include>>)      | 점선 + 꺾쇠 화살표           | 특정 유스케이스가 항상 다른 유스케이스를 포함할 때 사용 |
| 확장 관계(<<extend>>)       | 점선 + 꺾쇠 화살표           | 조건이 만족될 때만 추가로 실행되는 유스케이스를 연결    |
| 일반화 관계(Generalization) | 실선 + 빈 삼각형 화살표      | 액터 또는 유스케이스 간의 상속 관계 (상위 → 하위)       |

#### 클래스 다이어그램

클래스 다이어그램: 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 다이어그램

| 구성 요소            | 표현 방법                               | 내용                                                                  |
| -------------------- | --------------------------------------- | --------------------------------------------------------------------- |
| 클래스(Class)        | 사각형(Box), 3구획 (이름 / 속성 / 연산) | 객체의 설계도. 속성과 연산(메서드)을 포함하여 시스템의 구조 정의      |
| 제약조건(Constraint) | 중괄호 `{}` 안에 조건 작성              | 속성 값 제한, 관계 조건 등 모델에 부가 정보를 명시 (ex. `{age >= 0}`) |
| 관계(Relationship)   | 선(화살표 등 다양한 기호 사용)          | 클래스 간의 연관성, 상속, 포함 등을 표현 (연관, 집합, 상속 등 포함)   |

#### 순차 다이어그램

순차 다이어그램: 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것

| 구성요소              | 표현방법                                      | 의미                                                               |
| --------------------- | --------------------------------------------- | ------------------------------------------------------------------ |
| 액터(Actor)           | 사람 아이콘 또는 사각형 + 액터 이름           | 시스템 외부의 사용자 또는 다른 시스템으로서 메시지를 주고받는 주체 |
| 객체(Object)          | 사각형 안에 `객체명:클래스명` 형태로 표시     | 시스템 내부에서 동작하는 실제 객체. 메시지를 주고받는 대상         |
| 생명선(Lifeline)      | 객체 또는 액터 아래로 이어진 점선             | 시간의 흐름을 따라 객체가 존재함을 나타냄                          |
| 실행 상자(Activation) | 생명선 위의 직사각형 (얇고 세로로 긴 박스)    | 객체가 메시지를 처리하고 있는 시간 구간을 표현                     |
| 메시지(Message)       | 생명선 사이를 가로지르는 화살표 (→ 또는 ↔ 등) | 객체 간의 상호작용(호출, 응답, 반환 등). 동기/비동기 메시지로 나뉨 |

#### 패키지 다이어그램

패키지 다이어그램: 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것

| 구성요소              | 표현방법                                       | 의미                                                                    |
| --------------------- | ---------------------------------------------- | ----------------------------------------------------------------------- |
| 패키지(Package)       | 상단에 탭이 있는 사각형 (폴더 아이콘처럼 생김) | 관련 클래스, 인터페이스 등을 논리적으로 그룹화한 단위                   |
| 객체(Class/Object)    | 일반적인 클래스 표기와 동일                    | 패키지 내부에 포함되는 실제 구성 요소 (클래스, 인터페이스 등)           |
| 의존 관계(Dependency) | 점선 화살표 (────▷)                            | 한 패키지가 다른 패키지나 클래스에 의존할 때 사용 (수정 영향 관계 표현) |

## 소프트웨어 개발 방법론

소프트웨어 개발 방법론: 소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이에 필요한 각종 기법 및 도구를 정리하여 표준화한 것

### 구조적 방법론

구조적 방법론: 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론

- 복잡한 문제에 대해 분할과 정복(Divide and Conquer) 원리를 적용함

### 정보공학 방법론

정보공학 방법론: 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론

### 객체지향 방법론

객체지향 방법론: 객체들을 조립하여 소프트웨어를 구현하는 방법론

- 구성 요소: 객체, 클래스, 메시지 등
- 기본 원칙: 캡슐화, 정보 은닉, 추상화, 상속성, 다형성

### 컴포넌트 기반 방법론

컴포넌트 기반 방법론: 컴포넌트를 조합하여 새로운 애플리케이션을 만드는 방법론

- 컴포넌트를 재사용하여 시간과 노력을 절감할 수 있고, 새로운 기능을 추가하는 것이 간단하여 확장성이 보장됨

## SW 공학의 발전적 추세

### 소프트웨어 재사용

소프트웨어 재사용: 이미 개발되어 인정바든 소포트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것

- 합성 중심 재사용: 블록을 만들어 끼워 맞추듯 소프트웨어를 완성시키는 방법으로 블록 구성이라고도 함
- 생성 중심 재사용: 추상화 형태로 써진 명세를 구체화하여 프로그램을 만듬

### 소프트웨어 재공학

소프트웨어 재공학(Reengineering): 기존 시스템을 이용하여 보다 나은 시스템을 구축하고 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것

### CASE(Computer Aided Software Engineering)

CASE: 소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 소프트웨어를 사용하여 자동화하는 것

## 비용 산정 기법

### 상향식 비용 산정 기법

상향식 비용 산정 기법: 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법

- 주요 기법: LOC(원시 코드 라인 수) 기법, 개발 단계 인월수 기법, 수학적 산정 기법

### LOC(source Line Of Code) 기법

LOC 기법: 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법

- 예측치 == (a + 4m + b) / 6
  - a: 낙관치, b: 비관치, m: 기대치(중간치)

### 개발 단계별 인월수 기법

- 기능 구현에 필요한 노력을 생명 주기의 각 단계별로 산정

### COCOMO(COnstructive COst Model) 모형

COCOMO 모형: LOC에 의한 비용 산정 기법

- 보햄이 제안하였고, LOC를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정

## 프로젝트 일정 계획

### PERT(Program Evaluation and Review Technique)

PERT: 전체 작업의 상호 관계를 표시하는 네트워크

- 3점 추정법 사용: 낙관치(O), 비관치(P), 기대치(M)에 대해 기대 시간 E = (O + 4M + P) / 6

### CPM(Critical Path Method)

CPM: 작업을 나열해 작업에 필요한 소요 기간을 예측하는 것으로, 가장 오래 걸리는 경로(Critical Path)를 찾아 프로젝트 전체 기간을 예측

## 소프트웨어 개발 표준

소프트웨어 개발 표준: 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준

### ISO/IEC 12207

ISO/IEC 12207: ISO에서 만든 표준 소프트웨어 생명 주기 프로세스

- 기본 생명 주기 프로세스: 획득, 공급, 개발, 운영, 유지보수
- 지원 생명 주기 프로세스: 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결
- 조직 생명 주기 프로세스: 관리, 기반 구조, 훈련, 개선

### CMMI(Capability Maturity Model Integration)

CMMI: 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델

- 초기(Initial), 관리(Managed), 정의(Defined), 정량적 관리(Quantitatively Managed), 최적화(Optimizing) 프로세스로 나뉨

### SPICE(Software Process Improvement and Capability dEtermination)

SPICE: 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준(ISO/IEC 15504)

- 구성: 고객-공급자 프로세스, 공학 프로세스, 지원 프로세스, 관리 프로세스, 조직 프로세스

- 수행 능력 단계: 불완전, 수행 관리, 확립, 예측, 최적화

## 소프트웨어 개발 프레임워크

프레임워크: 소프트웨어 개발에 공통적으로 사용되는 구성요소와 아키텍처를 일반화하여 여러 기능을 제공해주는 반제품(중간 제품) 형태의 소프트웨어

- 주요 기능: 예외처리, 트랜잭션 처리, 메모리 공유, 데이터 소스 관리, 서비스 관리, 쿼링, 로깅, 사용자 인증 서비스

- 특성: 모듈화, 재사용성, 확장성, 제어의 역흐름(Inversion of Control)

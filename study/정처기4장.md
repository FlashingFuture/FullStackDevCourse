# 서버 프로그램 구현

## 소프트웨어 아키텍처

소프트웨어 아키텍처: 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

### 모듈화

모듈화: 시스템의 기능들을 모듈 단위로 나누는 것

### 추상화

추상화: 전체적이고 포괄적인 개념을 설계한 후, 차례로 세분화하며 구체화시켜 나가는 것

- 과정 추상화, 데이터 추상화, 제어 추상화

### 단계적 분해

단계적 분해: 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법

### 정보 은닉

정보 은닉: 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

### 상위 설계와 하위 설계

- 상위 설계: 아키텍처 설계, 예비 설계 등으로 시스템의 전체적인 구조(구조, DB, 인터페이스)를 설계함
- 하위 설계: 모듈 설계, 상세 설계 등으로 시스템의 내부 구조 및 행위(컴포넌트, 자료구조, 알고리즘)을 설계함

## 아키텍처 패턴

아키텍처 패턴: 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

### 레이어 패턴

레이어 패턴: 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴

### 클라이언트-서버 패턴

클라이언트-서버 패턴: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

### 파이프-필터 패턴

파이프-필터 패턴: 데이터 스트림 절차를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴

- 앞 시스템의 결과물을 파이프롤 통해 전달받고 처리 후 파이프를 통해

### 모델-뷰-컨트롤러 패턴

MVC 패턴: 서브시스템을 모델, 뷰, 컨트롤러로 구조화하여, 컨트롤러가 사용자의 요청을 받으면 핵심 기느오가 데이터를 보관하는 모델을 이용해 뷰에 정보를 출력하는 구조

### 마스터-슬레이브 패턴

마스터-슬레이브 패턴: 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴턴

## 객체지향

객체지향: 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립하여 소프트웨어를 개발하는 기법

### 객체지향의 구성 요소

- 객체: 데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈
- 클래스: 공통된 속성과 연산을 갖는 객체의 집합
  - 각각의 개체가 갖는 속성과 연산을 정의하는 틀로, 클래스에 속한 각각의 객체를 인스턴스라고 함
- 메시지: 객체들 간 상호작용을 하는 데 사용되는 수단으로, 객체에게 특정 행위를 하도록 지시하는 명령 또는 지시사항

### 객체지향의 특징

- 캡슐화(Encapsulation): 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것
- 상속(Inheritance): 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 다형성(Polymorphism): 하나의 메시지에 대해 각각의 객체가 가진 고유한 방법으로 응답할 수 있는 능력

## 객체지향 분석 및 설계

객체지향 분석: 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 것

### 객체지향 분석 방법론

- 럼바우 방법: 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
- 부치 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하여 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- 제이콥슨 방법: 유스케이스를 강조하여 사용
- Coad와 Yourdon 방법: ERD를 사용하여 객체 행위를 모델링

### 럼바우 분석 기법

럼바우 분석 기법: 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법

- 객체 모델링 -> 동적 모델링 -> 기능 모델링 의 순서로 진행

- 객체 모델링: 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
- 동적 모델링: 상태 다이어그램을 이용해 시간의 흐름에 따른 객체들 간 제어 흐름, 상호 작용, 동작 순서 등 동적인 행위를 표혀낳는 모데링
- 기능 모델링: 자료 흐름도(DFD)를 이용해 다수의 프로세스 간 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체지향 설계 원칙

- SRP(단일 책임 원칙): 객체는 단 하나의 책임만 가져야 함
- OCP(개방-폐쇄 원칙): 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 하는 원칙
- LSP(리스코프 치환 원칙): 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 하는 원칙
- ISP(인터페이스 분리 원칙): 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받아서는 안 되는 원칙
- DIP(의존 역전 원칙): 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 하는 원칙

## 모듈

모듈: 모듈화를 통해 분리된 시스템의 각 기능으로 서브루틴, 서브시스템, 소프트웨어 내 프로그램, 작업 단위 등을 의미

- 모듈의 독립성은 결합도와 응집도에 의해 측정됨

### 결합도

결합도(Coupling): 모듈 간 상호 의존하는 정도

| 결합도 정도 | 종류                          | 내용 설명                                                  |
| ----------- | ----------------------------- | ---------------------------------------------------------- |
| 강함        | 내용 결합 (Content Coupling)  | 한 모듈이 다른 모듈 내부의 내용(로직, 변수 등)에 직접 접근 |
|             | 공통 결합 (Common Coupling)   | 여러 모듈이 전역 변수 등을 공유하여 상호작용               |
|             | 외부 결합 (External Coupling) | 모듈이 인터페이스, 외부 데이터 포맷 등을 공유              |
|             | 제어 결합 (Control Coupling)  | 어떤 모듈이 다른 모듈에게 제어 정보를 인자로 전달          |
|             | 스탬프 결합 (Stamp Coupling)  | 필요한 데이터 일부가 아닌 전체 자료구조를 전달             |
| 약함        | 자료 결합 (Data Coupling)     | 필요한 데이터만 인자로 전달. 가장 바람직한 형태            |

- 결합도가 낮을수록 모듈 간 의존성이 줄어들고 유지보수성과 재사용성이 좋아짐

### 응집도

응집도(Cohesion): 모듈의 내부 요소들이 서로 관련되어 있는 정도

| 응집도 정도 | 종류                                   | 내용 설명                                                  |
| ----------- | -------------------------------------- | ---------------------------------------------------------- |
| 낮음        | 우연적 응집 (Coincidental Cohesion)    | 관련 없는 기능들이 하나의 모듈에 우연히 모여 있음          |
|             | 논리적 응집 (Logical Cohesion)         | 유사한 성격의 기능을 하나로 묶되, 제어 흐름에 따라 실행    |
|             | 시간적 응집 (Temporal Cohesion)        | 특정 시점에 함께 실행되는 기능을 묶음 (예: 초기화 작업 등) |
|             | 절차적 응집 (Procedural Cohesion)      | 특정 순서에 따라 실행되어야 하는 작업들을 묶음             |
|             | 통신적 응집 (Communicational Cohesion) | 동일한 데이터를 사용하는 작업들을 묶음                     |
|             | 순차적 응집 (Sequential Cohesion)      | 한 작업의 출력이 다음 작업의 입력으로 이어짐               |
| 높음        | 기능적 응집 (Functional Cohesion)      | 모듈이 하나의 명확한 기능만 수행. 가장 이상적인 응집도     |

- 응집도가 높을 수록 모듈이 하나의 책임에 집중하여 이해가 쉽고 수정 / 재사용이 쉬워짐

### 팬인 / 팬아웃

- 팬인(Fan-In): 어떤 모듈을 제어하는 모듈의 수
- 팬아웃(Fan-Out): 어떤 모듈에 의해 제어되는 모듈의 수
  - 팬인이 높다면 재사용 측면에서 설계가 잘 되어있으나, 단일 장애점(하나의 동작 오류로 전체 시스템이 중단되어 버리는 요소)가 발생할 수 있음

### N-S 차트

N-S(Nassi-Schneiderman) 차트: 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법

## 단위 모듈

단위 모듈: 한 가지 동작을 수행하는 기능을 모듈로 구현한 것

- 단위 기능 명세서 작성 -> 입/출력 기능 구현 -> 알고리즘 구현 의 과정으로 이루어짐

### IPC

IPC(Inter-Process Communication): 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합

- IPC 대표 메서드: Shared Memory, Socket, Semaphores, Pipes&named Pipes, Messeage Queueing

| 메서드(Method)                            | 특징 설명                                                                                                                                |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Shared Memory (공유 메모리)               | - 여러 프로세스가 **공통의 메모리 공간**을 공유해 데이터를 주고받음<br>- 빠른 속도를 제공하지만 동기화가 필요 (ex: 세마포어와 함께 사용) |
| Socket (소켓)                             | - **네트워크 기반 통신** 방식으로, 로컬 또는 원격 프로세스 간 통신 가능<br>- TCP/UDP를 이용하며 클라이언트-서버 구조에 적합              |
| Semaphores (세마포어)                     | - **동기화 도구**로, 공유 자원에 대한 접근을 제어<br>- 공유 메모리 등과 함께 사용되며, **데이터 전송보다는 접근 제어에 사용**            |
| Pipes & Named Pipes (파이프, 명명 파이프) | - **한 방향 통신** (기본 파이프는 부모-자식 간)<br>- Named Pipe는 이름을 붙여 **비연관 프로세스 간**에도 사용 가능                       |
| Message Queue (메시지 큐)                 | - 운영체제가 관리하는 **큐 구조에 메시지를 저장하고 읽는 방식**<br>- 비동기 통신이 가능하고, 메시지 크기와 수에 제한이 있음              |

### 테스트 케이스

테스트 케이스: 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서

- 식별자, 테스트 항목, 입력 명세, 출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술 로 구성됨

## 디자인 패턴

디자인 패턴: 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 문제해결 방식 또는 예제

- GOF의 디자인 패턴은 **생성, 구조, 행위** 패턴으로 구분

### 생성 패턴

생성 패턴: 클래스나 객체의 생성과 참조 과정을 정의하는 패턴

#### 추상 팩토리(Abstract Factory)

- 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관 / 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 연관된 서브클래스를 묶어 한 번에 교체하는 것이 가능

#### 빌더(Builder)

- 작게 분리된 인스턴스를 건축하듯 조합해 객체를 생성
- 객체의 생성 과정과 표현 방법을 분리해 동일한 객체 생성에서도 다른 결과를 만들어 낼 수 있음

#### 팩토리 메서드

- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
- 가상 생성자(Virtual Constructor) 패턴이라고도 함

#### 프로토타입

- 원본 객체를 복제하는 방법으로 객체를 생성
- 일반적인 방법으로 객체를 생성, 비용이 큰 경우 주로 이용

#### 싱글톤

- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 한 프로세스만이 한 번에 참조할 수 있음(여러 프로세스가 동시 참조 불가능)

### 구조 패턴

구조 패턴: 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

#### 어댑터

- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 기존 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

#### 브리지

- 구현부에서 추상층을 분리하여 서로 독립적으로 확장할 수 있도록 구성한 페턴
- 기능과 구현을 두 개의 별도 클래스로 구현

#### 데코레이터

- 객체 간 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

#### 퍼사드(Facade)

- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성해 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 서버 클래스들의 통합 인터페이스를 제공하는 Wrapper 객체 필요

#### 프록시

- 접근이 어려운 객체와 이에 연결하려는 객체 사이 인터페이스 역할을 수행하는 패턴
- 내부에서는 객체 간 복잡한 관계를 단순하게 정리하고 외부에서는 객체의 세부적인 내용을 숨김

### 행위 패턴

행위 패턴: 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

#### 커맨드

- 요청을 객체의 형태로 캡슐화하는 패턴
- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화

#### 중재자(Mediator)

- 객체들 간의 복잡한 상호작용(interface)을 캡슐화하여 객체로 정의하는 패턴
- 객체 사이 의존성을 줄여 결합도를 감소시킴

#### 옵저버(Observer)

- 객체의 상태가 변화하면 객체에 상속되어 잇는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 1:N 의 의존성을 정의
- 분산된 시스템 간 이벤트를 생성 / 발행하고 수신할 때 용이

#### 상태(State)

- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때, 객체 상태를 캡슐화하고 이를 참조하여 사용하는 패턴

#### 전략(Strategy)

- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있도록 정의하는 패턴
